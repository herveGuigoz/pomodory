// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'round.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$RoundTearOff {
  const _$RoundTearOff();

  Work work() {
    return const Work();
  }

  ShortBreak shortBreak() {
    return const ShortBreak();
  }

  LongBreak longBreak() {
    return const LongBreak();
  }
}

/// @nodoc
const $Round = _$RoundTearOff();

/// @nodoc
mixin _$Round {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() work,
    required TResult Function() shortBreak,
    required TResult Function() longBreak,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? work,
    TResult Function()? shortBreak,
    TResult Function()? longBreak,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? work,
    TResult Function()? shortBreak,
    TResult Function()? longBreak,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Work value) work,
    required TResult Function(ShortBreak value) shortBreak,
    required TResult Function(LongBreak value) longBreak,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Work value)? work,
    TResult Function(ShortBreak value)? shortBreak,
    TResult Function(LongBreak value)? longBreak,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Work value)? work,
    TResult Function(ShortBreak value)? shortBreak,
    TResult Function(LongBreak value)? longBreak,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RoundCopyWith<$Res> {
  factory $RoundCopyWith(Round value, $Res Function(Round) then) =
      _$RoundCopyWithImpl<$Res>;
}

/// @nodoc
class _$RoundCopyWithImpl<$Res> implements $RoundCopyWith<$Res> {
  _$RoundCopyWithImpl(this._value, this._then);

  final Round _value;
  // ignore: unused_field
  final $Res Function(Round) _then;
}

/// @nodoc
abstract class $WorkCopyWith<$Res> {
  factory $WorkCopyWith(Work value, $Res Function(Work) then) =
      _$WorkCopyWithImpl<$Res>;
}

/// @nodoc
class _$WorkCopyWithImpl<$Res> extends _$RoundCopyWithImpl<$Res>
    implements $WorkCopyWith<$Res> {
  _$WorkCopyWithImpl(Work _value, $Res Function(Work) _then)
      : super(_value, (v) => _then(v as Work));

  @override
  Work get _value => super._value as Work;
}

/// @nodoc

class _$Work extends Work with DiagnosticableTreeMixin {
  const _$Work() : super._();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'Round.work()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'Round.work'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is Work);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() work,
    required TResult Function() shortBreak,
    required TResult Function() longBreak,
  }) {
    return work();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? work,
    TResult Function()? shortBreak,
    TResult Function()? longBreak,
  }) {
    return work?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? work,
    TResult Function()? shortBreak,
    TResult Function()? longBreak,
    required TResult orElse(),
  }) {
    if (work != null) {
      return work();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Work value) work,
    required TResult Function(ShortBreak value) shortBreak,
    required TResult Function(LongBreak value) longBreak,
  }) {
    return work(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Work value)? work,
    TResult Function(ShortBreak value)? shortBreak,
    TResult Function(LongBreak value)? longBreak,
  }) {
    return work?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Work value)? work,
    TResult Function(ShortBreak value)? shortBreak,
    TResult Function(LongBreak value)? longBreak,
    required TResult orElse(),
  }) {
    if (work != null) {
      return work(this);
    }
    return orElse();
  }
}

abstract class Work extends Round {
  const factory Work() = _$Work;
  const Work._() : super._();
}

/// @nodoc
abstract class $ShortBreakCopyWith<$Res> {
  factory $ShortBreakCopyWith(
          ShortBreak value, $Res Function(ShortBreak) then) =
      _$ShortBreakCopyWithImpl<$Res>;
}

/// @nodoc
class _$ShortBreakCopyWithImpl<$Res> extends _$RoundCopyWithImpl<$Res>
    implements $ShortBreakCopyWith<$Res> {
  _$ShortBreakCopyWithImpl(ShortBreak _value, $Res Function(ShortBreak) _then)
      : super(_value, (v) => _then(v as ShortBreak));

  @override
  ShortBreak get _value => super._value as ShortBreak;
}

/// @nodoc

class _$ShortBreak extends ShortBreak with DiagnosticableTreeMixin {
  const _$ShortBreak() : super._();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'Round.shortBreak()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'Round.shortBreak'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is ShortBreak);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() work,
    required TResult Function() shortBreak,
    required TResult Function() longBreak,
  }) {
    return shortBreak();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? work,
    TResult Function()? shortBreak,
    TResult Function()? longBreak,
  }) {
    return shortBreak?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? work,
    TResult Function()? shortBreak,
    TResult Function()? longBreak,
    required TResult orElse(),
  }) {
    if (shortBreak != null) {
      return shortBreak();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Work value) work,
    required TResult Function(ShortBreak value) shortBreak,
    required TResult Function(LongBreak value) longBreak,
  }) {
    return shortBreak(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Work value)? work,
    TResult Function(ShortBreak value)? shortBreak,
    TResult Function(LongBreak value)? longBreak,
  }) {
    return shortBreak?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Work value)? work,
    TResult Function(ShortBreak value)? shortBreak,
    TResult Function(LongBreak value)? longBreak,
    required TResult orElse(),
  }) {
    if (shortBreak != null) {
      return shortBreak(this);
    }
    return orElse();
  }
}

abstract class ShortBreak extends Round {
  const factory ShortBreak() = _$ShortBreak;
  const ShortBreak._() : super._();
}

/// @nodoc
abstract class $LongBreakCopyWith<$Res> {
  factory $LongBreakCopyWith(LongBreak value, $Res Function(LongBreak) then) =
      _$LongBreakCopyWithImpl<$Res>;
}

/// @nodoc
class _$LongBreakCopyWithImpl<$Res> extends _$RoundCopyWithImpl<$Res>
    implements $LongBreakCopyWith<$Res> {
  _$LongBreakCopyWithImpl(LongBreak _value, $Res Function(LongBreak) _then)
      : super(_value, (v) => _then(v as LongBreak));

  @override
  LongBreak get _value => super._value as LongBreak;
}

/// @nodoc

class _$LongBreak extends LongBreak with DiagnosticableTreeMixin {
  const _$LongBreak() : super._();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'Round.longBreak()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'Round.longBreak'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is LongBreak);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() work,
    required TResult Function() shortBreak,
    required TResult Function() longBreak,
  }) {
    return longBreak();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? work,
    TResult Function()? shortBreak,
    TResult Function()? longBreak,
  }) {
    return longBreak?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? work,
    TResult Function()? shortBreak,
    TResult Function()? longBreak,
    required TResult orElse(),
  }) {
    if (longBreak != null) {
      return longBreak();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Work value) work,
    required TResult Function(ShortBreak value) shortBreak,
    required TResult Function(LongBreak value) longBreak,
  }) {
    return longBreak(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Work value)? work,
    TResult Function(ShortBreak value)? shortBreak,
    TResult Function(LongBreak value)? longBreak,
  }) {
    return longBreak?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Work value)? work,
    TResult Function(ShortBreak value)? shortBreak,
    TResult Function(LongBreak value)? longBreak,
    required TResult orElse(),
  }) {
    if (longBreak != null) {
      return longBreak(this);
    }
    return orElse();
  }
}

abstract class LongBreak extends Round {
  const factory LongBreak() = _$LongBreak;
  const LongBreak._() : super._();
}
